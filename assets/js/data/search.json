[ { "title": "CGAL 5.5 数值类型", "url": "/lazy.github.io/posts/number-types/", "categories": "CG, GEOMETRY", "tags": "cgal", "date": "2022-10-05 00:00:00 +0800", "snippet": "https://doc.cgal.org/latest/Number_types/index.html#Chapter_Number_Types1 介绍本章节概述了 CGAL 支持的数值类型。数值类型必须满足某些语法和语义要求，这样才能被用于 CGAL 代码。总体上，它们是代数结构的模型。如果它们是实数子环的模型，它们也是 RealEmbeddable 的模型。2 内置数值类型内置数值类型 float、double 和 long double 具有所需的算术和比较运算符。它们缺少一些必需的例行程序，尽管这些例行程序被 CGAL 自动包含。所有 C++ 内置数值类型只能表示有理数的离散（有..." }, { "title": "CGAL 5.5 三维快速相交和距离计算（AABB Tree）", "url": "/lazy.github.io/posts/aabb-tree/", "categories": "CG, GEOMETRY", "tags": "cgal", "date": "2022-09-06 00:00:00 +0800", "snippet": "https://doc.cgal.org/latest/AABB_tree/index.html#Chapter_3D_Fast_Intersection_and_Distance_Computation1 介绍AABB tree 组件体提供静态数据结构和算法，以对三维几何对象进行有效的相交和距离查询。相交查询可以是任何类型，只要对应相交谓词和构造在特征类中实现。距离查询限制为点查询。注意此组件不适用于查找所有相交对象对。AABB tree 数据结构将几何数据迭代器范围作为输入，然后将其转换为基元。AABBs 由这些基元构造，并用于加速相交和距离查询。每个基元可以访问输入几何对象与对象的..." }, { "title": "CGAL 5.5 多边形网格处理", "url": "/lazy.github.io/posts/p-m-p/", "categories": "CG, GEOMETRY", "tags": "cgal", "date": "2022-09-05 00:00:00 +0800", "snippet": "https://doc.cgal.org/latest/Polygon_mesh_processing/index.html#title581 介绍该包实现了一系列用于多边形网格处理的方法和类，从基础操作到复杂几何处理算法。该包的实现主要遵循 Botsch 等人的著作 Polygon Mesh Processing。1.1 多边形网格多边形网格是一致、有向的表面网格，包含一个或多个边界。面为简单多边形，边为线段。每条边连接两个顶点，由两个面共享。多边形网格可以有任意数量的连通分量和自相交。该包视多边形网格为二维流形。1.2 API该包遵循 CGAL and the Boost Graph..." }, { "title": "Geometry Images", "url": "/lazy.github.io/posts/geometry-images/", "categories": "CG, GEOMETRY", "tags": "paper", "date": "2022-05-31 00:00:00 +0800", "snippet": "摘要曲面几何通常使用不规则网格建模。重网格化过程指，使用半规则连通性近似这样的几何，这有利于许多图形应用。然而，现在的重网格化技术只能创建半规则网格。原始网格通常被分解为圆盘状的图表，在图表上对几何进行参数化和采样。在这篇文章中，我们将任意曲面重网格化为完全规则结构，并称之为几何图像。它将几何捕获为二维数组，其中存储了量化的点。曲面信号，例如法线和颜色，使用相同的隐式曲面参数化（纹理坐标缺失）存储在二维数组中。为了创建几何图像，我们沿着边连成的网络对网格进行切割，将生成的图表参数化为正方形。几何图像可以使用传统的图像压缩算法编码，例如基于小波的编码器。关键词： remeshing, su..." }, { "title": "Unity 2020.3.22f1 快捷键", "url": "/lazy.github.io/posts/unity-shortcut-key/", "categories": "CG, UNITY", "tags": "unity", "date": "2021-12-01 00:00:00 +0800", "snippet": "middle 拖动right 观察alt + left 围绕运动alt + right 缩放W A S D + right 移动F 视野平移并缩放到当前选中对象shift 加速移动W 平移E 旋转R 缩放T 矩形工具ctrl + shift + N 新建游戏对象ctrl + P 运行游戏ctrl + R 刷新对象" }, { "title": "Mixed-Integer Quadrangulation", "url": "/lazy.github.io/posts/mixed-integer-quadrangulation/", "categories": "CG, GEOMETRY", "tags": "paper", "date": "2021-11-20 01:00:00 +0800", "snippet": "摘要我们提出了一种四边形化给定三角网格的新颖方法。构造尽可能光滑的、满足方向约束稀疏集合的十字标架场，然后网格被切开以实现低失真的展开。之后计算无缝全局光滑参数化，等参线沿着十字标架场的方向。与之前的方法相比较，在四边形化的过程中，稀疏分布方向约束足以自动决定奇异点的数目、类型和位置。算法的两个步骤（十字标架场和参数化）可以被表示为混合整数问题，我们通过自适应贪婪求解器有效地求解。我们展示了一些复杂的例子，高质量的四边形网格完全自动生成。1 介绍常用质量标准： 1 单个元素质量：四边形应该接近矩形或正方形。 2 朝向：网格边缘应正交于主曲率方向。 3..." }, { "title": "三角网格惯性张量", "url": "/lazy.github.io/posts/the-moment-of-inertia/", "categories": "CG, SIMULATION", "tags": "moment of inertia", "date": "2021-11-20 00:00:00 +0800", "snippet": "1 前言1.1 惯性张量  在刚体动力学中，惯性张量描述质量如何在物体中分布。对于一个对象集合，其惯性张量为各对象惯性张量的和。角动量 $L$ 为惯性张量 $I$ 和角速度 $\\omega$ 的乘积。\\[L=I\\omega\\]  对于由质点构成的物体，记 $r_i$ 为第 $i$ 个质点的位置向量，记 $m_i$ 为第 $i$ 个质点的质量，且用 $E$ 表示单位矩阵。于是有\\[I=\\sum_{}{m_i(r_i^2E-{r_i}\\otimes{r_i})}\\]式中的 $\\otimes$ 表示张量积。1.2 质心  通过对离散的质点进行加权平均，可以求得质心 $c$。\\[c=\\frac{..." }, { "title": "Blender 2.93 Python API", "url": "/lazy.github.io/posts/blender-python-api/", "categories": "CG, BLENDER", "tags": "blender", "date": "2021-09-20 00:01:00 +0800", "snippet": "https://docs.blender.org/api/current/info_quickstart.htmlQuickstart: New to Blender or scripting and want to get your feet wet?Blender Python API 特性： 编辑用户界面可以编辑的任何数据（场景、网格、粒子等）。 修改用户首选项、键盘映射和主题。 使用个人设置运行工具。 创建用户界面元素。 创建新工具。 创建交互式工具。 创建与 Blender 集成的新渲..." }, { "title": "Blender 2.93 快捷键", "url": "/lazy.github.io/posts/blender-shortcut-key/", "categories": "CG, BLENDER", "tags": "blender", "date": "2021-09-20 00:00:00 +0800", "snippet": "shift + middle 平移ctrl + middle 缩放alt + middle 吸附旋转0 切换视角1 前视图ctrl + 1 后视图3 右视图7 顶视图5 投影切换9 翻转. 聚焦选中物体/ 聚焦选中物体，屏蔽其他物体shift + left 多选ctrl + left 连选或少选ctrl + right 套索选择N 侧栏T 工具栏G + X Y Z + (shift) 移动S + X Y Z + (shift) 缩放R + X Y Z + (shift) 旋转alt + G S R 返回默认shift + A 添加shift + Z 着色方式切换shift + D 复制a..." }, { "title": "CGAL 5.3 表面网格", "url": "/lazy.github.io/posts/surface-mesh/", "categories": "CG, GEOMETRY", "tags": "cgal", "date": "2021-08-26 00:02:00 +0800", "snippet": "https://doc.cgal.org/latest/Surface_mesh/index.html#Chapter_3D_Surface_mesh类 Surface_mesh 是一个半边数据结构的实现，用于表示多面体表面。它是包 Halfedge Data Structures 和包 3D Polyhedral Surface 的替代。主要区别在于它基于索引而不是指针。此外，向顶点、半边、边和面添加信息的机制更加简单，在运行时完成而不是编译时。因为该数据结构使用整数索引作为顶点、半边、边和面的描述符，所以它比基于64位指针的版本具有更低的内存占用。由于索引是连续的，它们可以用作存储属..." }, { "title": "CGAL 5.3 三维多面体表面", "url": "/lazy.github.io/posts/3d-polyhedral-surface/", "categories": "CG, GEOMETRY", "tags": "cgal", "date": "2021-08-26 00:01:00 +0800", "snippet": "https://doc.cgal.org/latest/Polyhedron/index.html#Chapter_3D_Polyhedral_Surfaces1 介绍三维多面体表面由顶点、边、面和它们之间的邻接关系组成。下面的组织是半边数据结构，其限制可表示的表面类别为可定向二维流形（有边界和无边界）。如果表面是闭合的，我们称之为多面体。多面体表面被视为容器类，它管理顶点、半边、面以及关联，并且维护它们的组合完整性。它基于半边数据结构的高度灵活设计。然而，多面体表面可以在不知道底层设计的情况下使用和理解。本章的一些例子也会逐步介绍这种灵活性的首次应用。2 定义三维多面体表面 Polyh..." }, { "title": "CGAL 5.3 半边数据结构", "url": "/lazy.github.io/posts/halfedge-data-structures/", "categories": "CG, GEOMETRY", "tags": "cgal", "date": "2021-08-26 00:00:00 +0800", "snippet": "https://doc.cgal.org/latest/HalfedgeDS/index.html#Chapter_Halfedge_Data_Structures1 介绍半边数据结构是以边为中心的数据结构，能够维护顶点、边和面的关联信息。每个边被分解为两个相反方向的半边。每个半边存储一个关联面和关联顶点。对于每个面和每个顶点，存储一个关联半边。半边数据结构的简化变体可能省略一些信息。图1半边数据结构是一种组合数据结构，几何解释由构建在半边数据结构之上的类添加。这些类可能比直接使用半边数据结构更方便，因为半边数据结构意味着作为一个实现层。参见多面体表面一章中的 Polyhedron_3 ..." }, { "title": "HELLO IMGUI", "url": "/lazy.github.io/posts/hello-imgui/", "categories": "C++, IMGUI", "tags": "imgui", "date": "2021-07-30 00:00:00 +0800", "snippet": "Dear ImGui 是一个轻量的 C++ 图形用户界面库。使用ImGui 的核心自包含在几个平台无关的文件中，可以轻松地在你的应用或引擎中编译它们。它们都是存储库根目录下的文件。无需特定的构建过程。你只需添加 .cpp 文件到你现有的项目。需要一个后端以在应用中集成 ImGui。后端处理键鼠输入和各种设置，并且负责渲染顶点。对于多种图形 API 和渲染平台的后端被提供。ImGui 允许创建精心制作的工具和生命期短暂的工具。工作原理ImGui 试图从用户角度最小化冗余状态副本、状态同步和状态保持。相比传统的状态保留界面，它更不易出错并且可以创建动态界面。ImGui 输出顶点缓冲区和命令列..." }, { "title": "A Material Point Method for Snow Simulation", "url": "/lazy.github.io/posts/snow/", "categories": "CG, SIMULATION", "tags": "paper", "date": "2021-07-24 10:00:00 +0800", "snippet": "摘要雪对于可视化模拟是一种有挑战性的自然现象。虽然图形学社区考虑过雪的积累和渲染，但雪动态的动画仍未被很好解决。另外，现有的固体和流体技术难以产生令人信服的雪的效果。具体来说，具有固体和液体性质的“湿”或“密”的雪难以处理。因此，这篇文章提出了一种新颖的雪模拟方法，即利用通过混合欧拉-拉格朗日物质点法积分的用户可控弹塑性自构模型。该方法基于连续介质，其混合性质允许我们使用规则笛卡尔网格自动处理自碰撞和裂缝。它也允许我们导出基于网格的半隐式积分方案，该方案条件独立于拉格朗日粒子数。我们通过一系列关于雪的现象，包括与复杂角色交互，展现这种方法的能力。1 介绍雪的动态美丽多变。无论是雪在滑雪者..." }, { "title": "Taichi 0.7.22 GUI 系统", "url": "/lazy.github.io/posts/gui-system/", "categories": "CG, SIMULATION", "tags": "taichi", "date": "2021-07-24 04:00:00 +0800", "snippet": "创建窗体 ti.GUI(title = &#39;Taichi&#39;, res = (512, 512), background_color = 0x000000, show_gui = True, fullscreen = False) res：标量或元组。 background_color：十六进制 rgb。 gui = ti.GUI(&#39;Window Title&#39;, (640, 360)) gui.show(filename = None)指定文件名将保存截图。在窗体上绘制太极 GUI 支持绘制简单的几何对象。位置(0.0, 0.0)..." }, { "title": "Taichi 0.7.22 高级编程", "url": "/lazy.github.io/posts/advanced-programming/", "categories": "CG, SIMULATION", "tags": "taichi", "date": "2021-07-24 03:00:00 +0800", "snippet": "Metaprogramming太极提供元编程基础设施，元编程可以统一维度依赖的代码开发、提高运行时的性能、简化太极标准库的开发。太极内核被延迟实例化，大量计算发生在编译时。每一个太极内核都是模板内核，即使没有模板参数。模板元编程@ti.kerneldef copy(x: ti.template(), y: ti.template()): for i in x: y[i] = x[i]a = ti.field(ti.f32, 4)b = ti.field(ti.f32, 4)c = ti.field(ti.f32, 12)d = ti.field(ti.f32, 12)..." }, { "title": "Taichi 0.7.22 API 参考", "url": "/lazy.github.io/posts/api-references/", "categories": "CG, SIMULATION", "tags": "taichi", "date": "2021-07-24 02:00:00 +0800", "snippet": "Scalar fields标量场最多有8个维度。 0维标量场即一个标量。 1维标量场为一维线性数组。 2维标量场用于二维的值。 3维标量场用于体数据。 标量场可以是稀疏或稠密的，这里仅考虑稠密标量场。声明ti.field(dtype, shape = None, offset = None)x = ti.field(ti.i32, shape=4)x = ti.field(ti.f32, shape=(4, 3))x = ti.field(ti.f32, shape=()) # 使用None作为索引# equivalent to: ..." }, { "title": "Taichi 0.7.22 HELLO TAICHI", "url": "/lazy.github.io/posts/hello-taichi/", "categories": "CG, SIMULATION", "tags": "taichi", "date": "2021-07-24 00:00:00 +0800", "snippet": "OVERVIEWHello,world!import taichi as ti# 初始化ti.init(arch=ti.gpu) # 在GPU上运行，自动选择后端（CUDA-&amp;gt;OpenGL-&amp;gt;CPU）ti.init(arch=cuda)ti.init(arch=opengl)ti.init(arch=cpu)当在 Windows 或 ARM 设备上使用 CUDA 后端时，太极默认为字段存储分配1 GB显存。# 指定太极作用域@ti.kernel # 被python代码调用，指定参数类型@ti.func # 被太极内核或函数调用支持嵌套函数，不支持递归函数..." }, { "title": "记博客搭建过程", "url": "/lazy.github.io/posts/notes-on-the-blog-building-process/", "categories": "探寻神秘之旅, 博客", "tags": "博客", "date": "2021-05-27 20:00:00 +0800", "snippet": "一、前言该博客使用 GitHub Pages 和 Jekyll 搭建，选用 Chirpy 作为博客主题模板。二、安装环境 注意安装路径不要有空格！ 首先安装 Ruby 和 Devkit，在下载页面选择 Ruby+Devkit 2.7.3-1 (x64)。 图1图2图3 安装程序运行结束时，安装 MSYS2。输入3然后回车，结束后退出。图4 然后安装 RubyGems，在下载页面下载压缩包 rubygems-3.2.17.zip。在解压后的文件目录下，执行命令 ruby setup.rb 再之后依次执行 gem install bundl..." } ]
